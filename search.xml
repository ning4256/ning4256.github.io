<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java学习]]></title>
    <url>%2F2018%2F10%2F30%2Fjava%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[java基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 第一个Java程序12345public class HelloWorld &#123; public static void main(String []args)&#123; System.out.println(&quot;Hello,world!&quot;); &#125;&#125; 对象和类类可以看成创建对象的模板。12345678public class Dog &#123; String breed; int age; String color; void barking()&#123; &#125;&#125; 一个类可以包含以下类型变量 局部变量：在方法、构造方法或者语句块中定义的变量。 成员变量：定义在类中，方法体之外的变量。 类变量:声明为static类型。 创建对象 声明一个对象 实例化，使用关键字new创建一个对象。 初始化，使用new创建对象是，会调用构造方法初始化对象。12345678public class Puppy &#123; public Puppy(String name) &#123; System.out.println(&quot;我的小狗的名字是&quot; + name); &#125; public static void main(String []args) &#123; Puppy myPuppy = new Puppy(&quot;小黄&quot;) &#125;&#125; 访问实例变量和方法ObjectReference = new Constructor,ObjectReference.variablename,ObjectReference.methodName()]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL数据库的学习]]></title>
    <url>%2F2018%2F10%2F30%2FMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是数据库数据库（DATABASE）是按照数据结构来组织、存储、和管理数据的仓库。关系型数据的特点： 数据以表格的形式出现。 每行行各种记录的名称。 每列为记录名称所对象的数据域。 许多行和列组成一张表单。 若干的表单组成DATABASE。 MYSQL的安装详情请参照该网站配置。 MYSQL的相关操作创建数据库CREATE DATABASE 数据库名例如：CREATE DATABASE scholl，创建一个名为scholl的数据库。然后use 数据库名就使用该数据库了。 删除数据库DROP DATABASE 数据库名例如：DROP DATABASE scholl，删除名为scholl的数据库。 MYSQL的数据类型MYSQL支持多种类型，大致可以分为三类：数值、日期和字符串。 数值类型这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 创建数据表创建MySQL数据表需要以下信息 表名 表字段名 定义每个表字段CREATE TABLE 表名 (字段名 字段类型)例如：CREATE TABLE class ( name VARCHAR, id INT )删除数据表DROP TABLE 表名例如：DROP TABLE class删除一个名为class的数据表 插入数据MySQL表中使用INSERT INTO语句来插入数据。INSERT INTO 表名 VALUES （） 单行插入INSERT INTO 表名 VALUES () 多行插入INSERT INTO 表名 VALUES (),() 更新数据MySQL表中使用UPDATE 表名 SET 数据名称=新值 [WHERE 条件判断]UPDATE class SET grade=60 WHERE name=&quot;小凡&quot; 删除数据MySQL表中使用DELETE FROM 表名 [WHERE 条件]DELETE FROM class WHERE grade&lt;60 一个例子： 向学生表插入4行数据INSERT INTO score (sname,snum,cname,grade) values(“王五”,3,”英语”,59.5),(“赵六”,4,”语文”,99.5),(“田七”,5,”数学”,7),(“王八”,6,”思想品德”,3);– 2. 将所有不及格 的成绩在原来基础之上加5分– 3.将王五的成绩降到40– 4.删除表低于30分的成绩– 5.两种方式删除表中所有数据123456789101112131415161718192021CREATE DATABASE school;use scholl;CREATE TABLE score ( sname VARCHAR(4), snum TINYINT, cname VARCHAR(4), grade float)INSERT INTO score (sname,snum,cname,grade) VALUES (&quot;王五&quot;,3,&quot;英语&quot;,59.5),(&quot;赵六&quot;,4,&quot;语文&quot;,99.5),(&quot;田七&quot;,5,&quot;数学&quot;,7),(&quot;王八&quot;,6,&quot;思想品德&quot;,3);UPDATE score SET grade = grade + 5 WHERES grade &lt; 60;UPDATE score SET grade = 40 WHERE sname = &quot;王五&quot;;DELETE FEOM score WHERE grade &lt; 30;DORP TABLE score //删除表全部数据和表结构TRUNCATE TAVLE score //删除表全部数据，保留表结构DELETE FROM score //删除表全部数据，表结构不变 数据完整性数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。 组成 实体完整性 域完整性 参照完整性 自定义完整性 主键(PRIMARY KEY)定义：表中有一列或几列的值能用来唯一的表示表中的每一行。 两种方式添加主键1234567891.CREATE TABLE class ( sname VARCHAR(4), snum INT PRIMARY KEY, sage TINYINT)2.ALTER TABLE class ADD PRIMARY KEY(snum) 删除主键ALTER TABLE class DROP PRIMARY KEY 外键(FOREIGN KEY)定义：字表对应于主表的列，体现了引用完整性、列完整性。主键唯一，外键多个。添加外键12345678CREATE TABLE class2 ( sname VARCHAR(4), snum INT, sage TINYINT, PRIMARY KEY (snum), FOREIGN KEY (sname) REFERENCES student(class1))ALTER TABLE class2 ADD FOREIGN KEY (sname) REFERENCES student(class1) 删除外键ALTER TABLE class2 DROP FOREIGN KEY (sname) 自增长(AUTO_INCREMENT)体现了实体的完整性，常搭配主键一起使用。123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT, ssex VARCHAR(2)) 唯一约束(unique)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY UNIQUE, sage TINYINT, ssex VARCHAR(2)) 非空约束(NOT NULL)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY NOT NULL, sage TINYINT, ssex VARCHAR(2)) 检查约束(SET(类型))123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY, sage TINYINT, ssex VARCHAR(2) SET(&quot;男&quot;, &quot;女&quot;)) 默认值约束(default)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT DEFAULTE &quot;18&quot;, ssex VARCHAR(2)) 三大范式 确保每列都保持原子性 确保每行都具有唯一性(拥有主键) 确保每列都和主键直接相关，而不是间接相关。 一个实例123456789101112131415161718192021222324252627282930313233343536373839404142434445-- CREATE DATABASE admin;-- USE admin;CREATE TABLE user_info ( user_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_nickname VARCHAR(10) UNIQUE, user_iphone VARCHAR(11) UNIQUE NOT NULL, user_email VARCHAR(40) UNIQUE NOT NULL, user_sex VARCHAR(8) NOT NULL, user_age TINYINT NOT NULL, user_address VARCHAR(40) NOT NULL)CREATE TABLE user_login_table ( user_login_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_login_userId VARCHAR(20) UNIQUE NOT NULL, user_login_username VARCHAR(20) UNIQUE NOT NULL, user_login_password VARCHAR(20) NOT NULL)CREATE TABLE product_table ( product_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, product_name VARCHAR(20) NOT NULL, product_num INT NOT NULL, product_price FLOAT NOT NULL, product_description VARCHAR(100), product_createDate DATE NOT NULL, product_date DATE)CREATE TABLE shoppingcar( shoppingcar_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, shoppingcar_product_name VARCHAR(20), shoppingcar_num INT, shoppingcar_userId INT, FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id))CREATE TABLE hadShopping( hadShopping_shoppingcar_id INT, hadShopping_buyTine DATE, hadShopping_address VARCHAR(40),-- FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id) FOREIGN KEY(hadShopping_shoppingcar_id) REFERENCES product_table(product_id))]]></content>
      <categories>
        <category>MYSQL 数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB的使用]]></title>
    <url>%2F2018%2F10%2F25%2FmongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是MongoDB？ MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB的安装具体细节请参照该网站自行配置 MongoDB概念解析MongoDB的存储结构和以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件 基础Shell命令 show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。 use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。 show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。 db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。 数据操作基础命令 use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。 db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”}) db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find() db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。 db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。 db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”}) db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。 db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。 mongoose的使用Mongoose是一个开源的封装好的实现Node和MongoDB数据通讯的数据建模库。 mongoose的安装npm i mongoose -S 连接数据库在database目录下新建一个init.js文件。12345678910111213141516171819202122232425262728293031323334353637const mongoose = require(&apos;mongoose&apos;)const db = &quot;mongodb://localhost/smile-db&quot;exports.connect = ()=&gt;&#123; //连接数据库 mongoose.connect(db) let maxConnectTimes = 0 return new Promise((resolve,reject)=&gt;&#123; //把所有连接放到这里 //增加数据库监听事件 mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; console.log(&apos;***********数据库断开***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject() throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(&apos;***********数据库错误***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject(err) throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) //链接打开的时 mongoose.connection.once(&apos;open&apos;,()=&gt;&#123; console.log(&apos;MongoDB connected successfully&apos;) resolve() &#125;) &#125;)&#125; Mongoose的Schema建模Schema是以key-value形式Json格式的数据。 Schema中的数据类型 String ：字符串类型 Number ：数字类型 Date ： 日期类型 Boolean： 布尔类型 Buffer ： NodeJS buffer 类型 ObjectID ： 主键,一种特殊而且非常重要的类型 Mixed ：混合类型 Array ：集合类型 Mongoose中的三个概念 schema ：用来定义表的模版，实现和MongoDB数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。 model ：具备某张表操作能力的一个集合，是mongoose的核心能力。我们说的模型就是这个Mondel。 entity ：类似记录，由Model创建的实体，也具有影响数据库的操作能力。 初学定义一个Schema我们在database文件夹下新建一个Schema文件下，然后创建一个use.js文件12345678910111213const mongoose = require(&apos;mongoose&apos;) //引入Mongooseconst Schema = mongoose.Schema //声明Schemalet ObjectId = Schema.Types.ObjectId //声明Object类型//创建我们的用户Schemaconst userSchema = new Schema(&#123; UserId:ObjectId, userName:&#123;unique:true,type:String&#125;, password:String, createAt:&#123;type:Date,default:Date.now()&#125;, lastLoginAt:&#123;type:Date,default:Date.now()&#125;&#125;)//发布模型mongoose.model(&apos;User&apos;,userSchema) 载入Schema和插入查出数据我们在init.js文件中处理Schema。首先我们载入所有的Schema，然后再处理。安装globnpm i glob -S12const glob = require(&apos;glob&apos;)const &#123;resolve&#125; = require(&apos;path&apos;) //将一系列相对路径替换成绝对路径 123exports.initSchemas = () =&gt;&#123; glob.sync(resolve(__dirname,&apos;./schema/&apos;,&apos;**/*.js&apos;)).forEach(require)&#125; 123456789101112131415161718192021222324const Koa = require(&apos;koa&apos;)const app = new Koa()const mongoose = require(&apos;mongoose&apos;)const &#123;connect , initSchemas&#125; = require(&apos;./database/init.js&apos;)//立即执行函数;(async () =&gt;&#123; await connect() initSchemas() const User = mongoose.model(&apos;User&apos;) let oneUser = new User(&#123;userName:&apos;jspang13&apos;,password:&apos;123456&apos;&#125;) oneUser.save().then(()=&gt;&#123; console.log(&apos;插入成功&apos;) &#125;)let users = await User.findOne(&#123;&#125;).exec()console.log(&apos;------------------&apos;)console.log(users)console.log(&apos;------------------&apos;) &#125;)()app.use(async(ctx)=&gt;&#123; ctx.body = &apos;&lt;h1&gt;hello Koa2&lt;/h1&gt;&apos;&#125;)app.listen(3000,()=&gt;&#123; console.log(&apos;[Server] starting at port 3000&apos;)&#125;)]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习]]></title>
    <url>%2F2018%2F10%2F24%2Fnode%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Node.js是什么？ Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js的安装和配置这个在这里不过多阐述，更多内容请自行百度。 第一个Node.js文件在一个目录下创建一个nodejs的文件夹,同时在该文件夹下创建一个HelloWorld.js文件，其内容为1console.log(&apos;Hello,World!&apos;); 然后打开终端，进入该文件目录下，使用node HelloWorld.js就可以在终端看到 Hello,World!的字了，并且第一个nodejs文件就完成了。 node核心模块node具有众多的核心模块，比较常用的有 fs,http,path等 fs模块fs是node中用于 读取文件的，它常用的有 readFile()和writeFile()这两个方法，第一个参数都是文件地址，readFile()第二个参数就是一个回调函数，而writeFile()由于是写文件，故应当有写入内容，所以其第二个参数是data(string)，然后跟一个回调函数。 readFile()方法12345678910var fs = require(&apos;fs&apos;);fs.readFile(&apos;1.txt&apos;, (error, data) =&gt; &#123; if(error) &#123; console.log(&apos;读取文件失败，请稍后再试&apos;) &#125; else &#123; console.log(data.toString()) //读取的数据大多是二进制数据，所以需要将其转换为字符类型 &#125;&#125;) 同理，writeFile()方法12345678910var fs = require(&apos;fs&apos;);fs.writeFile(&apos;2.txt&apos;, &apos;我是写入的内容&apos;, (error) =&gt; &#123; if(error) &#123; console.log(&apos;写入文件失败，请稍后再试&apos;) &#125; else &#123; console.log(&apos;写入文件成功&apos;) &#125;&#125;) 比较上面两段代码，可以清楚的知道，readFile()方法有两个参数，而回调函数中有两个参数（error和data）；而writeFile()方法有三个参数，而回调函数就只有一个参数（error）了。 http模块http模块主要用于搭建http服务器，我们可以利用其构建后端服务，使我们的应用在web服务器上使用。1234567891011121314151617181920var http = require(&apos;http)var server = http.createServer()server.on(&apos;request&apos;, (req, res) =&gt; &#123; var url = res.url; if(url === &apos;/&apos;) &#123; fs.readFile(&apos;./index.html&apos;, (error, data) =&gt; &#123; if(error) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain;charset=utf-8&apos;) res.end(&apos;读取文件失败，请稍后再试！&apos;) &#125; else &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000, () =&gt; &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 常用查询Content-Type的网站 node实现Apache1234567891011121314151617181920212223var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; var url = req.url var pathFile = &apos;index.html&apos; if(pathFile !== &apos;/&apos;) &#123; pathFile = url &#125; fs.readFile(pathFile, function(err, data) &#123; if(err) &#123; console.log(&apos;读取文件失败&apos;) &#125; else &#123; res.end(data) &#125; &#125;) &#125;)server.listen(3000, function() &#123; console.log(&apos;the server is starting at port 3000!&apos;)&#125;) expressexpress作为一个被node封装好的http框架，使用十分频繁和场景。12345678910var express = require(&apos;express&apos;)var app = new express()app.get(&apos;/&apos;, function(req, res) &#123; res.end(&apos;这是主页面&apos;)&#125;)app.listen(3000, function() &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 使用express完成一个crud 模版引擎的安装npm i art-template express-art-template -S在文件中使用 123456配置art-template模版引擎app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))渲染模版引擎res.render(&apos;index.html&apos;, &#123; // 传入的对象通常是字符串需要通过JSON.parse()转移&#125;) 完整代码 123456789101112131415161718192021222324252627// 引包var express = require(&apos;express&apos;)var fs = require(&apos;fs&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求app.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;)// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;) router路由模块通常情况下，我们将需要请求的路径封装成一个router.js文件，里面封装好我们需要的路径和相应的请求回调函数和逻辑，使我们的文件逻辑清晰。1234567891011121314151617181920212223242526272829303132var express = require(&apos;express&apos;)var router = express.Router()var fs = require(&apos;fs&apos;)router.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;) router.get(&apos;/students&apos;, function(req, res) &#123;&#125;) router.post(&apos;/students&apos;, function(req, res) &#123;&#125;) router.get(&apos;/students/new&apos;, function(req, res) &#123;&#125;)router.post(&apos;/students/new&apos;, function(req, res) &#123;&#125;)module.exports = router 而在我们的app.js文件中就可以写成这样了1234567891011121314151617181920212223// 引包var express = require(&apos;express&apos;)var router = require(&apos;./router.js&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))// 使用路由app.use(router)app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;)module.exports = app 最后完整版app.js123456789101112131415161718192021222324252627//引包const express=require(&apos;express&apos;);const fs=require(&apos;fs&apos;);const bodyParser=require(&apos;body-parser&apos;);//用户路由routerconst user=require(&apos;./router/user&apos;);//创建服务器const app=express();//配置公共资源app.use(express.static(&apos;./public&apos;));//配置使用art-template 模版引擎app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));//配置body-parserapp.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(bodyParser.json());//分发路由app.use(user);//监听端口app.listen(3000,function()&#123; console.log(&apos;Server is Start&apos;);&#125;); userModel.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/**数据操作模块只负责处理数据*/const fs=require(&apos;fs&apos;);const DB=&apos;./db.json&apos;/*获得所有用户return []*/exports.findAllUser=function(callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; callback(null,JSON.parse(data).users); &#125; &#125;);&#125;/*根据id查找user*/exports.findUserById=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===id; &#125;); callback(null,findUser); &#125; &#125;);&#125;/*添加用户*/exports.addUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //设置id user.id =+users[users.length-1].id+1; user.id=user.id.toString(); //添加 users.push(user); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*修改用户*/exports.updateUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===user.id; &#125;); //修改 for(var key in findUser)&#123; findUser[key]=user[key]; &#125; var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*删除用户*/exports.DeleteUser=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var deleteUserID=users.findIndex(function(item)&#123; return item.id===id; &#125;); //删除数据 users.splice(deleteUserID,1); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125; router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//路由模块 根据请求路径配置请求方法//引包const express=require(&apos;express&apos;);//挂载Express的路由routerconst router=express.Router();//加载模型const userModel=require(&apos;../model/userModel&apos;);//设置文件数据库路径const dbPath=&apos;./db.json&apos;;//配置请求//查看用户列表router.get(&apos;/user&apos;,function(req,res)&#123; userModel.findAllUser(function(error,data)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;index.html&apos;,&#123; user:data &#125;); &#125; &#125;);&#125;);//添加用户页面router.get(&apos;/user/add&apos;,function(req,res)&#123;res.render(&apos;useradd.html&apos;);&#125;);//添加用户操作router.post(&apos;/user/add&apos;,function(req,res)&#123;var user=req.body;userModel.addUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//更新修改页面router.get(&apos;/user/update&apos;,function(req,res)&#123;var id=req.query.id;userModel.findUserById(id,function(error,data)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;userUpdate.html&apos;,&#123;user:data&#125;); &#125;&#125;);&#125;);//更新数据router.post(&apos;/user/update&apos;,function(req,res)&#123; var user=req.body; userModel.updateUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125; &#125;);&#125;);//删除数据router.get(&apos;/user/Delete&apos;,function(req,res)&#123;var id=req.query.id;userModel.DeleteUser(id,function(error)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//导出routermodule.exports=router;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
