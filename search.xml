<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leet-code]]></title>
    <url>%2F2018%2F11%2F15%2Fleet-code%2F</url>
    <content type="text"><![CDATA[9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ Java实现代码123456789101112131415class Solution &#123; public boolean isPalindrome(int x) &#123; // 排除x为负数，整十数(0对十取余也是0) if(x &lt; 0 || (x % 10 ==0 &amp;&amp; x != 0) )&#123; return false; &#125; // x为正整数的时候 int env = 0; while(x &gt; env) &#123; env = env * 10 + x % 10; x = x / 10; &#125; return (x == env || x == env / 10); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2018%2F11%2F13%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡算法12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class TestBubble2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr1 = &#123;11, 221, 321, 21, 214, 21, 13&#125;; bubble(arr1); System.out.println(Arrays.toString(arr1)); &#125; public static void bubble(int[] arr) &#123; if(arr == null || arr.length &lt; 2) &#123; return; &#125; int temp; boolean flag = true; for(int i = 0; i &lt; arr.length; i++) &#123; for(int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; &#125; &#125; if(flag) &#123; break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-networks]]></title>
    <url>%2F2018%2F11%2F08%2Fcomputer-networks%2F</url>
    <content type="text"><![CDATA[计算机网络计算机网络概述局域网定义：覆盖范围小，自己花钱买设备，带宽固定。交换机 汇聚层 接入层 广域网Internet数据包(TCP/IP协议通信传输中的数据单位) 数据帧(数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。) ip地址(最终要到的地址) mac地址(决定了吓一跳的地址) osi参考模型应用层：所有能产生网络流量的程序。表示层：在传输之前是否进行加密或者压缩处理。(出现乱码)会话层：查木马(netstat)传输层：可靠传输，流量控制。网络层：选择最佳路径，规划ip地址。数据链路层：帧的开始和结束。透明传输，差错校验。物理层：定义了网络接口的标准，电气标准。 TCP/IP协议应用层传输层(TCP头)：数据段网络层(IP头)：数据包数据链路层(MAC头)：数据帧物理层 物理层解决在连接在各种计算机的传输媒体上传输数据比特流。机械特性，电气特性，功能特性，过程特性。数字信号 =&gt; 调制解调器 =&gt; 模拟信号 =&gt; 调制解调器 =&gt; 数字信号 基本概念：单向通信，双向交替通信，双向同时通信。基带信号：来自信源的信号。带通信号：经过载波调制后的信号 常用的编码方式：比特流，归零制，曼彻斯特，差分曼彻斯特基本带通调制方法：调幅，调频，调相。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习]]></title>
    <url>%2F2018%2F10%2F30%2Fjava%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[java基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 第一个Java程序12345public class HelloWorld &#123; public static void main(String []args)&#123; System.out.println(&quot;Hello,world!&quot;); &#125;&#125; 对象和类类可以看成创建对象的模板。12345678public class Dog &#123; String breed; int age; String color; void barking()&#123; &#125;&#125; 一个类可以包含以下类型变量 局部变量：在方法、构造方法或者语句块中定义的变量。 成员变量：定义在类中，方法体之外的变量。 类变量:声明为static类型。 创建对象 声明一个对象 实例化，使用关键字new创建一个对象。 初始化，使用new创建对象是，会调用构造方法初始化对象。12345678public class Puppy &#123; public Puppy(String name) &#123; System.out.println(&quot;我的小狗的名字是&quot; + name); &#125; public static void main(String []args) &#123; Puppy myPuppy = new Puppy(&quot;小黄&quot;) &#125;&#125; 访问实例变量和方法ObjectReference = new Constructor,ObjectReference.variablename,ObjectReference.methodName() 基本数据类型 内置数据类型 引用数据类型 内置数据类型 byte：8位，有符号，最小值-128（-2^7），最大值是127（2^7-1）。 short：16位，有符号，最小值-32768（-2^15），最大值是32767（2^15-1）。 int：32位，有符号，最小值是-2,147,483,648（-2^31），最大值是 2,147,483,647（2^31 - 1）。 long：64位，最小值是9,223,372,036,854,775,808（-2^63），最大值是 9,223,372,036,854,775,807（2^63 -1）。 float：单精确，32位。 double：双精确，64位。 boolean：true,false,默认值是false。 char：单一的16位Unicode字符。 引用类型引用类型指向一个对象，指向对象的变量是引用变量。对象，数值都是引用数据类型，默认值位null。例如：Site site = new Site(&quot;Runoob&quot;)。 Java常量在Java中使用final关键字修饰变量，声明方式为final double PI = 3.14.159。常用名常用小写表示变量，大写表示常量。 自动类型转换整型、常量、字符型可以混合运算，不同类型先转化为同一类型，然后进行运算，转换从低级到高级。 变量类型 类变量：独立于方法之外的变量，用static修饰。 实例变量：独立于方法之外的变量，不要static修饰。 局部变量：类的方法之中的变量。 1234567public class Variable &#123; static int a = 0; //类变量 String str = &quot;hello,world&quot;; 实例变量 public void method()&#123; int i = 1; //局部变量 &#125;&#125; 循环 for循环 while循环 do while循环 foreach]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL数据库的学习]]></title>
    <url>%2F2018%2F10%2F30%2FMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是数据库数据库（DATABASE）是按照数据结构来组织、存储、和管理数据的仓库。关系型数据的特点： 数据以表格的形式出现。 每行行各种记录的名称。 每列为记录名称所对象的数据域。 许多行和列组成一张表单。 若干的表单组成DATABASE。 MYSQL的安装详情请参照该网站配置。 MYSQL的相关操作创建数据库CREATE DATABASE 数据库名例如：CREATE DATABASE scholl，创建一个名为scholl的数据库。然后use 数据库名就使用该数据库了。 删除数据库DROP DATABASE 数据库名例如：DROP DATABASE scholl，删除名为scholl的数据库。 MYSQL的数据类型MYSQL支持多种类型，大致可以分为三类：数值、日期和字符串。 数值类型这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 创建数据表创建MySQL数据表需要以下信息 表名 表字段名 定义每个表字段CREATE TABLE 表名 (字段名 字段类型)例如：CREATE TABLE class ( name VARCHAR, id INT )删除数据表DROP TABLE 表名例如：DROP TABLE class删除一个名为class的数据表TRUNCATE TABLE 表名删除表内所有数据，保留表结构。DELETE FROM 表名 WHERE 条件删除表内的数据，或者删除某一列。 插入数据MySQL表中使用INSERT INTO语句来插入数据。INSERT INTO 表名 VALUES （） 单行插入INSERT INTO 表名 VALUES () 多行插入INSERT INTO 表名 VALUES (),() 更新数据MySQL表中使用UPDATE 表名 SET 数据名称=新值 [WHERE 条件判断]UPDATE class SET grade=60 WHERE name=&quot;小凡&quot; 删除数据MySQL表中使用DELETE FROM 表名 [WHERE 条件]DELETE FROM class WHERE grade&lt;60 修改表结构alter table 表名 rename 新表名alter table 表名 add 新列名 新列的定义alter table 表名 change 旧列名 新列名 新列的定义 一个例子： 向学生表插入4行数据INSERT INTO score (sname,snum,cname,grade) values(“王五”,3,”英语”,59.5),(“赵六”,4,”语文”,99.5),(“田七”,5,”数学”,7),(“王八”,6,”思想品德”,3);– 2. 将所有不及格 的成绩在原来基础之上加5分– 3.将王五的成绩降到40– 4.删除表低于30分的成绩– 5.两种方式删除表中所有数据123456789101112131415161718192021CREATE DATABASE school;use scholl;CREATE TABLE score ( sname VARCHAR(4), snum TINYINT, cname VARCHAR(4), grade float)INSERT INTO score (sname,snum,cname,grade) VALUES (&quot;王五&quot;,3,&quot;英语&quot;,59.5),(&quot;赵六&quot;,4,&quot;语文&quot;,99.5),(&quot;田七&quot;,5,&quot;数学&quot;,7),(&quot;王八&quot;,6,&quot;思想品德&quot;,3);UPDATE score SET grade = grade + 5 WHERES grade &lt; 60;UPDATE score SET grade = 40 WHERE sname = &quot;王五&quot;;DELETE FEOM score WHERE grade &lt; 30;DORP TABLE score //删除表全部数据和表结构TRUNCATE TAVLE score //删除表全部数据，保留表结构DELETE FROM score //删除表全部数据，表结构不变 数据完整性数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。 组成 实体完整性 域完整性 参照完整性 自定义完整性 主键(PRIMARY KEY)定义：表中有一列或几列的值能用来唯一的表示表中的每一行。 两种方式添加主键1234567891.CREATE TABLE class ( sname VARCHAR(4), snum INT PRIMARY KEY, sage TINYINT)2.ALTER TABLE class ADD PRIMARY KEY(snum) 删除主键ALTER TABLE class DROP PRIMARY KEY 外键(FOREIGN KEY)定义：字表对应于主表的列，体现了引用完整性、列完整性。主键唯一，外键多个。添加外键12345678CREATE TABLE class2 ( sname VARCHAR(4), snum INT, sage TINYINT, PRIMARY KEY (snum), FOREIGN KEY (sname) REFERENCES student(class1))ALTER TABLE class2 ADD FOREIGN KEY (sname) REFERENCES student(class1) 删除外键ALTER TABLE class2 DROP FOREIGN KEY (sname) 自增长(AUTO_INCREMENT)体现了实体的完整性，常搭配主键一起使用。123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT, ssex VARCHAR(2)) 唯一约束(unique)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY UNIQUE, sage TINYINT, ssex VARCHAR(2)) 非空约束(NOT NULL)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY NOT NULL, sage TINYINT, ssex VARCHAR(2)) 检查约束(SET(类型))123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY, sage TINYINT, ssex VARCHAR(2) SET(&quot;男&quot;, &quot;女&quot;)) 默认值约束(default)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT DEFAULTE &quot;18&quot;, ssex VARCHAR(2)) 三大范式 确保每列都保持原子性 确保每行都具有唯一性(拥有主键) 确保每列都和主键直接相关，而不是间接相关。 一个实例123456789101112131415161718192021222324252627282930313233343536373839404142434445-- CREATE DATABASE admin;-- USE admin;CREATE TABLE user_info ( user_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_nickname VARCHAR(10) UNIQUE, user_iphone VARCHAR(11) UNIQUE NOT NULL, user_email VARCHAR(40) UNIQUE NOT NULL, user_sex VARCHAR(8) NOT NULL, user_age TINYINT NOT NULL, user_address VARCHAR(40) NOT NULL)CREATE TABLE user_login_table ( user_login_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_login_userId VARCHAR(20) UNIQUE NOT NULL, user_login_username VARCHAR(20) UNIQUE NOT NULL, user_login_password VARCHAR(20) NOT NULL)CREATE TABLE product_table ( product_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, product_name VARCHAR(20) NOT NULL, product_num INT NOT NULL, product_price FLOAT NOT NULL, product_description VARCHAR(100), product_createDate DATE NOT NULL, product_date DATE)CREATE TABLE shoppingcar( shoppingcar_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, shoppingcar_product_name VARCHAR(20), shoppingcar_num INT, shoppingcar_userId INT, FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id))CREATE TABLE hadShopping( hadShopping_shoppingcar_id INT, hadShopping_buyTine DATE, hadShopping_address VARCHAR(40),-- FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id) FOREIGN KEY(hadShopping_shoppingcar_id) REFERENCES product_table(product_id)) DQL(数据查询语言) 简单查询 复杂查询 聚合函数与分组 子查询 链接查询 简单查询SELECT 列名 FROM 表名 [WHERE 条件] [ORDER BY 列名] 查询所有信息SELECT * FROM student 按条件查询SELECT * FROM student Where sex=&quot;nv&quot; ORDER BY age; 重命名ASSELECT id AS 学生编号 FROM student 合并列作为一个新列SELECT 工资＋奖金 AS 收入 限制行数（limit）SELECT 列名 FROM 表名 WHERE age=10 LIMIT 起始行，行数; 不重复查询SELECT DISTINCT 列名 FROM 表名 模糊查询SELECT * FROM 表名 WHERE sname like &quot;c_&quot;; 复杂查询聚合函数与分组需求：查询数据表中的最高成绩，最低成绩，平均成绩，总成绩，成绩记录个数COUNT, SUM, AVG, MAX, MIN(行数， 总和， 平均， 最大， 最小)使用方法： select count(列名) from 表名 select sum(列名) from 表名 select avg(列名) from 表名 select max(列名) from 表名 select mix(列名) from 表名需求：查询每个同学的平均成绩。select sname,sum(grade) from 表名 GROUND BY courseId 多列分组select 列名 from 表名 GROUND BY 分组条件 HAVING 聚合条件s 查询顺序SELECT * FROM 表名 where 条件 GROUP BY 分组 HAVING 聚合函数过滤 ORDER BY LIMIT 子查询定义：可以解决需要结合多张表进行查询的需求。分类： 查询语句作为另一条查询语句的一个条件的值。需求：查询平均成绩大于60的学生姓名 123select sname from student; //从student表中查询snameselect sno from sc groud by sno having avg(score)&gt;60; //select sname from student where sno in (select sno from sc groud by sno having avg(score)&gt;60); 查询语句作为另一条查询语句的一张表。一般解题步骤：先找到核心需求，确定最终要查的表，将每个条件用单独的一条select语句表示出来，将所写出的语句通过表之间的外键联系起来。 视图查询保存查询语句集的展示形式，保存结果集的表 create view view_student_sc as 链接查询结合多张表完成更复杂的查询需求分类： 内连接(INNER JOIN)select sno,sname from studentselect sno from sc groud by sno having avg(score) between 60 and 80select sno,sname from student where sno in (select sno from sc groud by sno having avg(score) between 60 and 80) select * from student inner join sc on sc.sno=student.sno groud by sno having avg(score) having between 60 and 80 外联接（左外，右外） 高级特效(包含了DCL) 变量 1.1 用户变量SET @变量名=变量值 // 定义变量select @变量名 //输出变量1.1.1 全局变量show global variable 查看所有的全局变量在 my-default.ini文件里面修改全局变量1.2 系统变量1.3 局部变量1234567891011121314create procedure pro_if()begindeclare a tinyint;select min(age) into a from student;if a&lt;18 thenselect &quot;小孩子&quot;;elseif a&gt;18 and a&lt;60 thenselect &quot;大孩子&quot;;elseselect &quot;老孩子&quot;;end if;endcall pro_if; 存储过程带参数的 输入的形参 和 输出的形参 输出的形参 触发器体现自定义完整性，构建更加合理、健壮的数据库，数据检查问题。 事务将多个操作视为一个整体的概念特性：原子性，一致性，隔离性，持久性。 游标]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB的使用]]></title>
    <url>%2F2018%2F10%2F25%2FmongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是MongoDB？ MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB的安装具体细节请参照该网站自行配置 MongoDB概念解析MongoDB的存储结构和以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件 基础Shell命令 show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。 use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。 show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。 db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。 数据操作基础命令 use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。 db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”}) db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find() db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。 db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。 db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”}) db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。 db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。 mongoose的使用Mongoose是一个开源的封装好的实现Node和MongoDB数据通讯的数据建模库。 mongoose的安装npm i mongoose -S 连接数据库在database目录下新建一个init.js文件。12345678910111213141516171819202122232425262728293031323334353637const mongoose = require(&apos;mongoose&apos;)const db = &quot;mongodb://localhost/smile-db&quot;exports.connect = ()=&gt;&#123; //连接数据库 mongoose.connect(db) let maxConnectTimes = 0 return new Promise((resolve,reject)=&gt;&#123; //把所有连接放到这里 //增加数据库监听事件 mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; console.log(&apos;***********数据库断开***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject() throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(&apos;***********数据库错误***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject(err) throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) //链接打开的时 mongoose.connection.once(&apos;open&apos;,()=&gt;&#123; console.log(&apos;MongoDB connected successfully&apos;) resolve() &#125;) &#125;)&#125; Mongoose的Schema建模Schema是以key-value形式Json格式的数据。 Schema中的数据类型 String ：字符串类型 Number ：数字类型 Date ： 日期类型 Boolean： 布尔类型 Buffer ： NodeJS buffer 类型 ObjectID ： 主键,一种特殊而且非常重要的类型 Mixed ：混合类型 Array ：集合类型 Mongoose中的三个概念 schema ：用来定义表的模版，实现和MongoDB数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。 model ：具备某张表操作能力的一个集合，是mongoose的核心能力。我们说的模型就是这个Mondel。 entity ：类似记录，由Model创建的实体，也具有影响数据库的操作能力。 初学定义一个Schema我们在database文件夹下新建一个Schema文件下，然后创建一个use.js文件12345678910111213const mongoose = require(&apos;mongoose&apos;) //引入Mongooseconst Schema = mongoose.Schema //声明Schemalet ObjectId = Schema.Types.ObjectId //声明Object类型//创建我们的用户Schemaconst userSchema = new Schema(&#123; UserId:ObjectId, userName:&#123;unique:true,type:String&#125;, password:String, createAt:&#123;type:Date,default:Date.now()&#125;, lastLoginAt:&#123;type:Date,default:Date.now()&#125;&#125;)//发布模型mongoose.model(&apos;User&apos;,userSchema) 载入Schema和插入查出数据我们在init.js文件中处理Schema。首先我们载入所有的Schema，然后再处理。安装globnpm i glob -S12const glob = require(&apos;glob&apos;)const &#123;resolve&#125; = require(&apos;path&apos;) //将一系列相对路径替换成绝对路径 123exports.initSchemas = () =&gt;&#123; glob.sync(resolve(__dirname,&apos;./schema/&apos;,&apos;**/*.js&apos;)).forEach(require)&#125; 123456789101112131415161718192021222324const Koa = require(&apos;koa&apos;)const app = new Koa()const mongoose = require(&apos;mongoose&apos;)const &#123;connect , initSchemas&#125; = require(&apos;./database/init.js&apos;)//立即执行函数;(async () =&gt;&#123; await connect() initSchemas() const User = mongoose.model(&apos;User&apos;) let oneUser = new User(&#123;userName:&apos;jspang13&apos;,password:&apos;123456&apos;&#125;) oneUser.save().then(()=&gt;&#123; console.log(&apos;插入成功&apos;) &#125;)let users = await User.findOne(&#123;&#125;).exec()console.log(&apos;------------------&apos;)console.log(users)console.log(&apos;------------------&apos;) &#125;)()app.use(async(ctx)=&gt;&#123; ctx.body = &apos;&lt;h1&gt;hello Koa2&lt;/h1&gt;&apos;&#125;)app.listen(3000,()=&gt;&#123; console.log(&apos;[Server] starting at port 3000&apos;)&#125;)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习]]></title>
    <url>%2F2018%2F10%2F24%2Fnode%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Node.js是什么？ Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js的安装和配置这个在这里不过多阐述，更多内容请自行百度。 第一个Node.js文件在一个目录下创建一个nodejs的文件夹,同时在该文件夹下创建一个HelloWorld.js文件，其内容为1console.log(&apos;Hello,World!&apos;); 然后打开终端，进入该文件目录下，使用node HelloWorld.js就可以在终端看到 Hello,World!的字了，并且第一个nodejs文件就完成了。 node核心模块node具有众多的核心模块，比较常用的有 fs,http,path等 fs模块fs是node中用于 读取文件的，它常用的有 readFile()和writeFile()这两个方法，第一个参数都是文件地址，readFile()第二个参数就是一个回调函数，而writeFile()由于是写文件，故应当有写入内容，所以其第二个参数是data(string)，然后跟一个回调函数。 readFile()方法12345678910var fs = require(&apos;fs&apos;);fs.readFile(&apos;1.txt&apos;, (error, data) =&gt; &#123; if(error) &#123; console.log(&apos;读取文件失败，请稍后再试&apos;) &#125; else &#123; console.log(data.toString()) //读取的数据大多是二进制数据，所以需要将其转换为字符类型 &#125;&#125;) 同理，writeFile()方法12345678910var fs = require(&apos;fs&apos;);fs.writeFile(&apos;2.txt&apos;, &apos;我是写入的内容&apos;, (error) =&gt; &#123; if(error) &#123; console.log(&apos;写入文件失败，请稍后再试&apos;) &#125; else &#123; console.log(&apos;写入文件成功&apos;) &#125;&#125;) 比较上面两段代码，可以清楚的知道，readFile()方法有两个参数，而回调函数中有两个参数（error和data）；而writeFile()方法有三个参数，而回调函数就只有一个参数（error）了。 http模块http模块主要用于搭建http服务器，我们可以利用其构建后端服务，使我们的应用在web服务器上使用。1234567891011121314151617181920var http = require(&apos;http)var server = http.createServer()server.on(&apos;request&apos;, (req, res) =&gt; &#123; var url = res.url; if(url === &apos;/&apos;) &#123; fs.readFile(&apos;./index.html&apos;, (error, data) =&gt; &#123; if(error) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain;charset=utf-8&apos;) res.end(&apos;读取文件失败，请稍后再试！&apos;) &#125; else &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000, () =&gt; &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 常用查询Content-Type的网站 node实现Apache1234567891011121314151617181920212223var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; var url = req.url var pathFile = &apos;index.html&apos; if(pathFile !== &apos;/&apos;) &#123; pathFile = url &#125; fs.readFile(pathFile, function(err, data) &#123; if(err) &#123; console.log(&apos;读取文件失败&apos;) &#125; else &#123; res.end(data) &#125; &#125;) &#125;)server.listen(3000, function() &#123; console.log(&apos;the server is starting at port 3000!&apos;)&#125;) expressexpress作为一个被node封装好的http框架，使用十分频繁和场景。12345678910var express = require(&apos;express&apos;)var app = new express()app.get(&apos;/&apos;, function(req, res) &#123; res.end(&apos;这是主页面&apos;)&#125;)app.listen(3000, function() &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 使用express完成一个crud 模版引擎的安装npm i art-template express-art-template -S在文件中使用 123456配置art-template模版引擎app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))渲染模版引擎res.render(&apos;index.html&apos;, &#123; // 传入的对象通常是字符串需要通过JSON.parse()转移&#125;) 完整代码 123456789101112131415161718192021222324252627// 引包var express = require(&apos;express&apos;)var fs = require(&apos;fs&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求app.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;)// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;) router路由模块通常情况下，我们将需要请求的路径封装成一个router.js文件，里面封装好我们需要的路径和相应的请求回调函数和逻辑，使我们的文件逻辑清晰。1234567891011121314151617181920212223242526272829303132var express = require(&apos;express&apos;)var router = express.Router()var fs = require(&apos;fs&apos;)router.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;) router.get(&apos;/students&apos;, function(req, res) &#123;&#125;) router.post(&apos;/students&apos;, function(req, res) &#123;&#125;) router.get(&apos;/students/new&apos;, function(req, res) &#123;&#125;)router.post(&apos;/students/new&apos;, function(req, res) &#123;&#125;)module.exports = router 而在我们的app.js文件中就可以写成这样了1234567891011121314151617181920212223// 引包var express = require(&apos;express&apos;)var router = require(&apos;./router.js&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))// 使用路由app.use(router)app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;)module.exports = app 最后完整版app.js123456789101112131415161718192021222324252627//引包const express=require(&apos;express&apos;);const fs=require(&apos;fs&apos;);const bodyParser=require(&apos;body-parser&apos;);//用户路由routerconst user=require(&apos;./router/user&apos;);//创建服务器const app=express();//配置公共资源app.use(express.static(&apos;./public&apos;));//配置使用art-template 模版引擎app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));//配置body-parserapp.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(bodyParser.json());//分发路由app.use(user);//监听端口app.listen(3000,function()&#123; console.log(&apos;Server is Start&apos;);&#125;); userModel.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/**数据操作模块只负责处理数据*/const fs=require(&apos;fs&apos;);const DB=&apos;./db.json&apos;/*获得所有用户return []*/exports.findAllUser=function(callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; callback(null,JSON.parse(data).users); &#125; &#125;);&#125;/*根据id查找user*/exports.findUserById=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===id; &#125;); callback(null,findUser); &#125; &#125;);&#125;/*添加用户*/exports.addUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //设置id user.id =+users[users.length-1].id+1; user.id=user.id.toString(); //添加 users.push(user); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*修改用户*/exports.updateUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===user.id; &#125;); //修改 for(var key in findUser)&#123; findUser[key]=user[key]; &#125; var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*删除用户*/exports.DeleteUser=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var deleteUserID=users.findIndex(function(item)&#123; return item.id===id; &#125;); //删除数据 users.splice(deleteUserID,1); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125; router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//路由模块 根据请求路径配置请求方法//引包const express=require(&apos;express&apos;);//挂载Express的路由routerconst router=express.Router();//加载模型const userModel=require(&apos;../model/userModel&apos;);//设置文件数据库路径const dbPath=&apos;./db.json&apos;;//配置请求//查看用户列表router.get(&apos;/user&apos;,function(req,res)&#123; userModel.findAllUser(function(error,data)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;index.html&apos;,&#123; user:data &#125;); &#125; &#125;);&#125;);//添加用户页面router.get(&apos;/user/add&apos;,function(req,res)&#123;res.render(&apos;useradd.html&apos;);&#125;);//添加用户操作router.post(&apos;/user/add&apos;,function(req,res)&#123;var user=req.body;userModel.addUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//更新修改页面router.get(&apos;/user/update&apos;,function(req,res)&#123;var id=req.query.id;userModel.findUserById(id,function(error,data)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;userUpdate.html&apos;,&#123;user:data&#125;); &#125;&#125;);&#125;);//更新数据router.post(&apos;/user/update&apos;,function(req,res)&#123; var user=req.body; userModel.updateUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125; &#125;);&#125;);//删除数据router.get(&apos;/user/Delete&apos;,function(req,res)&#123;var id=req.query.id;userModel.DeleteUser(id,function(error)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//导出routermodule.exports=router;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
