<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java面试题总结]]></title>
    <url>%2F2019%2F04%2F12%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[常见的Java问题什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？ Java虚拟机是一个可以执行Java字节码文件的虚拟机进程。Java源文件被编译成能够被Java虚拟机执行的字节码文件。 Java是被设计为允许应用程序在任意平台都可以允许，不需要我们为每一个平台单独重写或者重新编译，Java虚拟机使其变成可能，因为它直到底层硬件平台的指令长度和其他特性。 JDK和JRE的区别是什么？ JRE是将要执行Java程序的Java虚拟机，它同时包含了执行applet需要的浏览器插件。 JDK是完整的Java程序开发包，包含了JRE、编译器和其他工具。所以，我们通常情况下，只需要下载JDK、配置好开发环境就可以了 “static”关键字是什么意思？Java能否覆盖(override)一个private或则static的方法 “static”关键字表名一个成员变量或者一个成员方法可以在没有所属类的实例变量的情况下被访问，也就是我们不用使用new关键字构建一个对象，使用类名.成员变量或者类名.成员方法就可以。 Java中的static方法不能被覆盖，因为方法覆盖是基于动态绑定的，而static方法使编译时静态绑定的。(换句话说，一个static方法，或者static属性，static代码块实在这个类加载时就被注册，而方法覆盖是动态的) 是否可以在static环境下访问非static变量 static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果我们尝试不用实例来访问一个非static的变量，那么编译器就会报错，因为这些变量还未被创建出来，还没有跟任何实例关联上 Java支持的数据类型有哪些？什么时候自动装箱？ Java语言支持的8种基本数据类型: 名称 字节数 byte 1 short 2 int 4 long 8 float 4 double 8 boolean 1 char 2 自动装箱是Java编译器在基本数据类型和对象的包装类型之间做的一个相互转换。 Java中方法覆盖(override)和重载(overload)是什么意思？ Java的方法覆盖通常是一个子类重新定义了其父类的方法，它们必须具有相同的方法名，参数列表和返回类型，父类的方法访问通常是public。 Java的方法重载发生同一个类中，两个或则多个方法具有相同的方法名但是他的参数不同(参数个数不同或则参数类型不同或则参数顺序不同) java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？ 当一个新对象被创建的时候，构造函数就会被调用。每一个类都有它的构造函数。当程序员没有给一个类提供构造函数的时候，Java编译器会自动给这个类创建一个默认的构造函数。 Java中的构造函数重载和方法的重载很相似。可以为一个类创建多个构造函数，而每一个构造函数都必须有它自己唯一的参数列表。 Java不支持复制构造函数。 Java支持多继承吗？ 不支持，Java支持单继承，每一个类都只能继承一个类，但可以实现多个接口。 接口和抽象类的区别是什么？ 接口中所有的方法隐含的都是抽象的，而抽象类可以同时包含抽象和非抽象的方法。 一个类可以实现多个接口，但一个类只能继承一个抽象类 一个类要实现一个接口，就必须实现它里面的所有方法。但一个类继承一个抽象类，就不必实现其所有的方法。 接口里声明的变量默认都是final，而抽象类可以包含非final的变量 接口中的成员函数默认都是public的，而抽象类的成员变量可以说private、protected或则public 接口是绝对抽象的、不可以被实例化。抽象类也不可以被实例化，但当它包含一个main方法的时候还是可以被调用的。 什么是值传递和引用传递 对象被值传递，意味着传递的是对象的一个副本。因此，就算改变了对象的副本，也不会影响源对象的值 对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。 &amp;和&amp;&amp;，|和||的区别 &amp;和&amp;&amp;： ** 共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true； ** 不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。 |和||： ** 共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false； **不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。 说一下转发(Forward)和重定向(Redirect)的区别？ 转发是服务器行为，重定向是客户端行为。 转发（Forword） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过HttpServletRequest 的 getRequestDispatcher()方法获得。 重定向（Redirect） 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议 浏览器查找域名的ip地址(DNS) 浏览器向web服务器发送一个HTTP请求 服务器处理请求 服务器发回一个HTML响应 浏览器开始显示HTML TCP 三次握手和四次挥手 客户端–发送带有 SYN 标志的数据包–一次握手–服务端 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端 HTTP请求,响应报文格式 HTTP请求报文主要由请求行、请求头部、请求正文3部分组成 HTTP响应报文主要由状态行、响应头部、响应正文3部分组成 Java线程进程和线程的区别是什么？ 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又被称为轻量级进程。 创建线程有几种不同的方式？ 继承Thread类 实现Runnable接口 应用程序可以使用Executor框架来创建线程池 通常情况下，实现Runnable接口比较受欢迎，因为不需要继承Thread类，在程序设计时，如果继承了其他的类，就无法继承多个类，这个时候就可以实现接口。同时，线程池也是非常高效的，比较容易实现和使用。 概述一下线程的几种可用状态 新建(new) 就绪(线程对象调用了start方法) 运行(Running)：进程正在执行线程的代码 阻塞(Block):线程停止执行 死亡(Dead):线程完成执行 同步方法和同步代码块的区别是什么？在Java中，每一个对象都有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可以应用在方法级别(粗颗粒锁)或则代码块级别(细颗粒锁)。 在监视器(Monitor)内部，是如何做到线程同步的？程序应该做哪种级别的同步？监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 什么是死锁两个进程都在等待对方执行完毕才能继续往下执行的时候就产生了死锁。结果就是两个进程都进入的无限的等待中 如何确保N个线程可以访问N个资源同时又不导致死锁使用多线程的时候，一种简单避免死锁的方式就是：指定获取锁的顺序，并且强制线程安装指定的顺序去获取锁。因此，如果所有的线程都是按照同样的顺序来加锁和释放锁，就不会出现死锁了 集合类集合类框架的基本接口有哪些？ Collection:代表一组对象，每个对象都是它的子元素 Set:不包含重复元素的Collection List:有顺序的Collection，并且可以包含重复的元素 Map:将键(key)映射到值(value)的对象，键不可以重复 为什么集合类没有实现Cloneable和Serializable接口集合类接口指定了一组叫做元素的对象。集合类接口的每一种的具体实现类都可以选择以它自己的方式对元素进行保存和排序。有的类允许重复的键，有的则不允许。 什么是迭代器(Iterator)Iterator接口提供了许多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器的实例 Java中的HashMap的工作原理是什么？Java中的HashMap是以键值对(key-value)的形式来存储元素的。HashMap需要一个hash函数，它使用hashcode()和equals()方法来向集合中添加和检索元素。当调用put方法的时候,hashMap会计算key的hash值，然后将键值对存储在集合中是和的索引上。如果key已经存在，那么value就会被更新。HashMap的一些重要的特性就是他的容量(capacity),负载因子(load factor)和扩容极限(threshold resizing)。 hashcode()和equals()方法的重要性体现在什么地方？Java中的HashMap是使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值得时候也会使用这两个方法。如果没有正确实现这两个方法，那么两个不同的键可能会有相同的hash值，可能会被集合认为是相等的。而且，这两个方法也用来发现重复的元素，所以这两个方法的实现对HashMap的精确性和正确性是很重要的 HashMap和HashTable有什么区别 HashMap允许键和值是null(键为null的只能又一个，值为null的可以有多个),HashTable不允许键或者值是null。 HashMap不是同步的，而HashTable是同步的。所以HashMap比较适合单线程环境，HashTable适用于多线程环境 HashTabl只是在HashMap的基础加了一个synchronized的锁 数组(Array)和(ArrayList)有什么区别，什么时候使用Array而不是ArrayList？ Array可以包含基本数据类型和对象数据类型，而ArrayList只能包含对象类型。 Array的大小是固定的，而ArrayList的大小是动态变化的 ArrayList提供了多种方法和特性，比如：addAll(),removeAll() ArrayList和LinkList的区别？ ArrayList是基于索引的数据接口，它的底层是数组，它可以以O(1)的时间复杂度对元素进行随机访问。LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素连接在一起，它的时间复杂度为O(n)。 ArrayList的查询、遍历速度更快。LinkedList的插入，删除操作速度更快。 LinkedList比ArrayList更占内存，因为LinkedList的每一个节点存储了两个引用。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot的学习]]></title>
    <url>%2F2019%2F04%2F01%2Fspringboot%2F</url>
    <content type="text"><![CDATA[springboot的学习SpringBoot简介 Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化Spring 应用项目的搭建以及开发过程 Spring由于各种XML、Annotation繁琐的配置，使开发变得复杂 SpringBoot的出现简化了开发Spring应用的开发步骤,开发一个应用不在需要繁琐的配置。 SpringBoot优点 Spring Boot遵循“习惯优于配置”的理念，帮助开发者快速搭建Spring框架 内嵌式容器，无需部署WAR文件 简化Maven配置 提供生产就绪型功能，如监控性能指标，健康检查和外部配置 基于SpringBoot技术项目的开发步骤 继承父启动器： pom.xml 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 开发启动类： 在启动类上添加注解：@SpringBootApplication 运行SpringBoot应用项目，启动内嵌的web容器：SpringApplication.run(启动类.class, args); 默认约定 / /* @Controller在SpringApplication.run()方法执行后，Spring Boot发现这是一个Web应用（根据类路径上的依赖确定），于是在内嵌的Tomcat容器中启动了一个Spring的应用上下文，并且监听默认的tcp端口8080（默认约定）。同时在Spring Context中根据默认的约定配置了Spring Web Mvc 容器默认的Context路径是/ DispatherServlet匹配的路径(servlet-mapping中的url-patterns)是/*@ComponentScan路径被默认设置为启动类的同名package及其子包，也就是该package下的所有@Controller，@Service, @Component, @Repository都会被实例化后并加入Spring Context中。 常用配置 server.port:定义端口号 默认是8080 server.servlet.context-path: 应用上下文路径,默认 / spring.thymeleaf.cache=false : 对thyemleaf模板页面不缓存 spring.mvc.date-format=yyyy-MM-dd 设置提交数据日期格式的处理 spring.jackson.date-format=yyyy-MM-dd hh:mm:ss json格式日期数据的处理 spring.jackson.time-zone=GMT+8 时区 spring.http.encoding.charset=UTF-8 字符编码 SpringBoot 配置文件 Spring boot 支持两种格式的配置文件 属性文件:applicaiton.properties yaml文件:application.yml 多环境配置文件的切换环境文件的命名格式 applicaion-{env}.yml applicaion-{env}.properties 如果使用不同的环境文件 application.yml进行配置： 123spring: profiles: active: env 自定义配置@Value 编写自定义配置文件 在启动类上添加注解，在项目启动的过程中来加载自定义配置文件：@PropertyResource(value=”路径”) 在项目中通过@Value注解来注入对应的数据。 @ConfigurationProperties 可以将配置文件中的数据，注入到某一个配置类中，注入给对应的属性。 编写自定义配置文件 在启动类上添加注解，在项目启动的过程中来加载自定义配置文件：@PropertyResource(value=”路径”) 在配置类上添加注解：@ConfigurationProperties(prefix=””) SpringBoot整合Mybatispom中配置启动器12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 配置数据源逆向工程Mybatis Generator 在启动类中添加注解@MapperScanner(value={“接口包”})加载mybatis sql映射文件12mybatis: mapper-locations: classpath:/mapper/*.xml SpringBoot单元测试 @RunWith(SpringRunner.class) @SpringBootTest SpringBoot整合jsp 推荐使用的模板引擎是Thyemleaf 手动建立一个webapp目录src/main/webapp 定义视图解析器 1234spring: view: suffix: .jsp prefix: /WEB-INF/page/ pom配置： 让内嵌的tomcat解析jsp 123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt;&lt;/dependency&gt; 整合外部的tomcat配置启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt; 启动类继承SpringBootServletInitializer重写config()方法 配置tomcat 并进行部署。SpringBoot中使用日志工具logback 在yml文件中进行配置日志的级别 logging.config 配置的是日志配置文件的名称 logging.file 记录日志的文件名称 logging.level.root 全局的日志级别 logging.level.包名 定义某个包的日志级别 如果需要详细的日志配置 在项目中添加一个 logback.xml配置文件 多环境下使用日志工具 将logback.xml —&gt;logback-spring.xml 在logback-spring.xml配置文件中，指定不同环境中输入日志的方式 123456&lt;springProfile name=&quot;dev&quot;&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;d:/logs/dev&quot; /&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;prd&quot;&gt; &lt;property name=&quot;LOG_HOME&quot; value=&quot;d:/logs/prd&quot; /&gt;&lt;/springProfile&gt; 使用mybatis分页插件 pageHelper依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; yml配置1234pagehelper: support-methods-arguments: true params: pageNum=currentPage,pageSize=pageSize helper-dialect: mysql]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leet-code]]></title>
    <url>%2F2018%2F11%2F15%2Fleet-code%2F</url>
    <content type="text"><![CDATA[9. 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:12输入: 121输出: true 示例 2:123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ Java实现代码123456789101112131415class Solution &#123; public boolean isPalindrome(int x) &#123; // 排除x为负数，整十数(0对十取余也是0) if(x &lt; 0 || (x % 10 ==0 &amp;&amp; x != 0) )&#123; return false; &#125; // x为正整数的时候 int env = 0; while(x &gt; env) &#123; env = env * 10 + x % 10; x = x / 10; &#125; return (x == env || x == env / 10); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法]]></title>
    <url>%2F2018%2F11%2F13%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡算法12345678910111213141516171819202122232425262728293031import java.util.Arrays;public class TestBubble2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] arr1 = &#123;11, 221, 321, 21, 214, 21, 13&#125;; bubble(arr1); System.out.println(Arrays.toString(arr1)); &#125; public static void bubble(int[] arr) &#123; if(arr == null || arr.length &lt; 2) &#123; return; &#125; int temp; boolean flag = true; for(int i = 0; i &lt; arr.length; i++) &#123; for(int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = false; &#125; &#125; if(flag) &#123; break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[computer-networks]]></title>
    <url>%2F2018%2F11%2F08%2Fcomputer-networks%2F</url>
    <content type="text"><![CDATA[计算机网络计算机网络概述局域网定义：覆盖范围小，自己花钱买设备，带宽固定。交换机 汇聚层 接入层 广域网Internet数据包(TCP/IP协议通信传输中的数据单位) 数据帧(数据链路层的协议数据单元，它包括三部分：帧头，数据部分，帧尾。) ip地址(最终要到的地址) mac地址(决定了吓一跳的地址) osi参考模型应用层：所有能产生网络流量的程序。表示层：在传输之前是否进行加密或者压缩处理。(出现乱码)会话层：查木马(netstat)传输层：可靠传输，流量控制。网络层：选择最佳路径，规划ip地址。数据链路层：帧的开始和结束。透明传输，差错校验。物理层：定义了网络接口的标准，电气标准。 TCP/IP协议应用层传输层(TCP头)：数据段网络层(IP头)：数据包数据链路层(MAC头)：数据帧物理层 物理层解决在连接在各种计算机的传输媒体上传输数据比特流。机械特性，电气特性，功能特性，过程特性。数字信号 =&gt; 调制解调器 =&gt; 模拟信号 =&gt; 调制解调器 =&gt; 数字信号 基本概念：单向通信，双向交替通信，双向同时通信。基带信号：来自信源的信号。带通信号：经过载波调制后的信号 常用的编码方式：比特流，归零制，曼彻斯特，差分曼彻斯特基本带通调制方法：调幅，调频，调相。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习]]></title>
    <url>%2F2018%2F10%2F30%2Fjava%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[java基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 第一个Java程序12345public class HelloWorld &#123; public static void main(String []args)&#123; System.out.println(&quot;Hello,world!&quot;); &#125;&#125; 对象和类类可以看成创建对象的模板。12345678public class Dog &#123; String breed; int age; String color; void barking()&#123; &#125;&#125; 一个类可以包含以下类型变量 局部变量：在方法、构造方法或者语句块中定义的变量。 成员变量：定义在类中，方法体之外的变量。 类变量:声明为static类型。 创建对象 声明一个对象 实例化，使用关键字new创建一个对象。 初始化，使用new创建对象是，会调用构造方法初始化对象。12345678public class Puppy &#123; public Puppy(String name) &#123; System.out.println(&quot;我的小狗的名字是&quot; + name); &#125; public static void main(String []args) &#123; Puppy myPuppy = new Puppy(&quot;小黄&quot;) &#125;&#125; 访问实例变量和方法ObjectReference = new Constructor,ObjectReference.variablename,ObjectReference.methodName() 基本数据类型 内置数据类型 引用数据类型 内置数据类型 byte：8位，有符号，最小值-128（-2^7），最大值是127（2^7-1）。 short：16位，有符号，最小值-32768（-2^15），最大值是32767（2^15-1）。 int：32位，有符号，最小值是-2,147,483,648（-2^31），最大值是 2,147,483,647（2^31 - 1）。 long：64位，最小值是9,223,372,036,854,775,808（-2^63），最大值是 9,223,372,036,854,775,807（2^63 -1）。 float：单精确，32位。 double：双精确，64位。 boolean：true,false,默认值是false。 char：单一的16位Unicode字符。 引用类型引用类型指向一个对象，指向对象的变量是引用变量。对象，数值都是引用数据类型，默认值位null。例如：Site site = new Site(&quot;Runoob&quot;)。 Java常量在Java中使用final关键字修饰变量，声明方式为final double PI = 3.14.159。常用名常用小写表示变量，大写表示常量。 自动类型转换整型、常量、字符型可以混合运算，不同类型先转化为同一类型，然后进行运算，转换从低级到高级。 变量类型 类变量：独立于方法之外的变量，用static修饰。 实例变量：独立于方法之外的变量，不要static修饰。 局部变量：类的方法之中的变量。 1234567public class Variable &#123; static int a = 0; //类变量 String str = &quot;hello,world&quot;; 实例变量 public void method()&#123; int i = 1; //局部变量 &#125;&#125; 循环 for循环 while循环 do while循环 foreach]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL数据库的学习]]></title>
    <url>%2F2018%2F10%2F30%2FMYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是数据库数据库（DATABASE）是按照数据结构来组织、存储、和管理数据的仓库。关系型数据的特点： 数据以表格的形式出现。 每行行各种记录的名称。 每列为记录名称所对象的数据域。 许多行和列组成一张表单。 若干的表单组成DATABASE。 MYSQL的安装详情请参照该网站配置。 MYSQL的相关操作创建数据库CREATE DATABASE 数据库名例如：CREATE DATABASE scholl，创建一个名为scholl的数据库。然后use 数据库名就使用该数据库了。 删除数据库DROP DATABASE 数据库名例如：DROP DATABASE scholl，删除名为scholl的数据库。 MYSQL的数据类型MYSQL支持多种类型，大致可以分为三类：数值、日期和字符串。 数值类型这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。 日期和时间类型表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。 字符串类型字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。 创建数据表创建MySQL数据表需要以下信息 表名 表字段名 定义每个表字段CREATE TABLE 表名 (字段名 字段类型)例如：CREATE TABLE class ( name VARCHAR, id INT )删除数据表DROP TABLE 表名例如：DROP TABLE class删除一个名为class的数据表TRUNCATE TABLE 表名删除表内所有数据，保留表结构。DELETE FROM 表名 WHERE 条件删除表内的数据，或者删除某一列。 插入数据MySQL表中使用INSERT INTO语句来插入数据。INSERT INTO 表名 VALUES （） 单行插入INSERT INTO 表名 VALUES () 多行插入INSERT INTO 表名 VALUES (),() 更新数据MySQL表中使用UPDATE 表名 SET 数据名称=新值 [WHERE 条件判断]UPDATE class SET grade=60 WHERE name=&quot;小凡&quot; 删除数据MySQL表中使用DELETE FROM 表名 [WHERE 条件]DELETE FROM class WHERE grade&lt;60 修改表结构alter table 表名 rename 新表名alter table 表名 add 新列名 新列的定义alter table 表名 change 旧列名 新列名 新列的定义 一个例子： 向学生表插入4行数据INSERT INTO score (sname,snum,cname,grade) values(“王五”,3,”英语”,59.5),(“赵六”,4,”语文”,99.5),(“田七”,5,”数学”,7),(“王八”,6,”思想品德”,3);– 2. 将所有不及格 的成绩在原来基础之上加5分– 3.将王五的成绩降到40– 4.删除表低于30分的成绩– 5.两种方式删除表中所有数据123456789101112131415161718192021CREATE DATABASE school;use scholl;CREATE TABLE score ( sname VARCHAR(4), snum TINYINT, cname VARCHAR(4), grade float)INSERT INTO score (sname,snum,cname,grade) VALUES (&quot;王五&quot;,3,&quot;英语&quot;,59.5),(&quot;赵六&quot;,4,&quot;语文&quot;,99.5),(&quot;田七&quot;,5,&quot;数学&quot;,7),(&quot;王八&quot;,6,&quot;思想品德&quot;,3);UPDATE score SET grade = grade + 5 WHERES grade &lt; 60;UPDATE score SET grade = 40 WHERE sname = &quot;王五&quot;;DELETE FEOM score WHERE grade &lt; 30;DORP TABLE score //删除表全部数据和表结构TRUNCATE TAVLE score //删除表全部数据，保留表结构DELETE FROM score //删除表全部数据，表结构不变 数据完整性数据库完整性（Database Integrity）是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。 组成 实体完整性 域完整性 参照完整性 自定义完整性 主键(PRIMARY KEY)定义：表中有一列或几列的值能用来唯一的表示表中的每一行。 两种方式添加主键1234567891.CREATE TABLE class ( sname VARCHAR(4), snum INT PRIMARY KEY, sage TINYINT)2.ALTER TABLE class ADD PRIMARY KEY(snum) 删除主键ALTER TABLE class DROP PRIMARY KEY 外键(FOREIGN KEY)定义：字表对应于主表的列，体现了引用完整性、列完整性。主键唯一，外键多个。添加外键12345678CREATE TABLE class2 ( sname VARCHAR(4), snum INT, sage TINYINT, PRIMARY KEY (snum), FOREIGN KEY (sname) REFERENCES student(class1))ALTER TABLE class2 ADD FOREIGN KEY (sname) REFERENCES student(class1) 删除外键ALTER TABLE class2 DROP FOREIGN KEY (sname) 自增长(AUTO_INCREMENT)体现了实体的完整性，常搭配主键一起使用。123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT, ssex VARCHAR(2)) 唯一约束(unique)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY UNIQUE, sage TINYINT, ssex VARCHAR(2)) 非空约束(NOT NULL)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY NOT NULL, sage TINYINT, ssex VARCHAR(2)) 检查约束(SET(类型))123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY, sage TINYINT, ssex VARCHAR(2) SET(&quot;男&quot;, &quot;女&quot;)) 默认值约束(default)123456CREATE TABLE class ( sname VARCHAR(8), snum PRIMARY KEY AUTO_INCREMENT, sage TINYINT DEFAULTE &quot;18&quot;, ssex VARCHAR(2)) 三大范式 确保每列都保持原子性 确保每行都具有唯一性(拥有主键) 确保每列都和主键直接相关，而不是间接相关。 一个实例123456789101112131415161718192021222324252627282930313233343536373839404142434445-- CREATE DATABASE admin;-- USE admin;CREATE TABLE user_info ( user_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_nickname VARCHAR(10) UNIQUE, user_iphone VARCHAR(11) UNIQUE NOT NULL, user_email VARCHAR(40) UNIQUE NOT NULL, user_sex VARCHAR(8) NOT NULL, user_age TINYINT NOT NULL, user_address VARCHAR(40) NOT NULL)CREATE TABLE user_login_table ( user_login_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, user_login_userId VARCHAR(20) UNIQUE NOT NULL, user_login_username VARCHAR(20) UNIQUE NOT NULL, user_login_password VARCHAR(20) NOT NULL)CREATE TABLE product_table ( product_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, product_name VARCHAR(20) NOT NULL, product_num INT NOT NULL, product_price FLOAT NOT NULL, product_description VARCHAR(100), product_createDate DATE NOT NULL, product_date DATE)CREATE TABLE shoppingcar( shoppingcar_id INT PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT, shoppingcar_product_name VARCHAR(20), shoppingcar_num INT, shoppingcar_userId INT, FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id))CREATE TABLE hadShopping( hadShopping_shoppingcar_id INT, hadShopping_buyTine DATE, hadShopping_address VARCHAR(40),-- FOREIGN KEY(shoppingcar_userId) REFERENCES user_info(user_id) FOREIGN KEY(hadShopping_shoppingcar_id) REFERENCES product_table(product_id)) DQL(数据查询语言) 简单查询 复杂查询 聚合函数与分组 子查询 链接查询 简单查询SELECT 列名 FROM 表名 [WHERE 条件] [ORDER BY 列名] 查询所有信息SELECT * FROM student 按条件查询SELECT * FROM student Where sex=&quot;nv&quot; ORDER BY age; 重命名ASSELECT id AS 学生编号 FROM student 合并列作为一个新列SELECT 工资＋奖金 AS 收入 限制行数（limit）SELECT 列名 FROM 表名 WHERE age=10 LIMIT 起始行，行数; 不重复查询SELECT DISTINCT 列名 FROM 表名 模糊查询SELECT * FROM 表名 WHERE sname like &quot;c_&quot;; 复杂查询聚合函数与分组需求：查询数据表中的最高成绩，最低成绩，平均成绩，总成绩，成绩记录个数COUNT, SUM, AVG, MAX, MIN(行数， 总和， 平均， 最大， 最小)使用方法： select count(列名) from 表名 select sum(列名) from 表名 select avg(列名) from 表名 select max(列名) from 表名 select mix(列名) from 表名需求：查询每个同学的平均成绩。select sname,sum(grade) from 表名 GROUND BY courseId 多列分组select 列名 from 表名 GROUND BY 分组条件 HAVING 聚合条件s 查询顺序SELECT * FROM 表名 where 条件 GROUP BY 分组 HAVING 聚合函数过滤 ORDER BY LIMIT 子查询定义：可以解决需要结合多张表进行查询的需求。分类： 查询语句作为另一条查询语句的一个条件的值。需求：查询平均成绩大于60的学生姓名 123select sname from student; //从student表中查询snameselect sno from sc groud by sno having avg(score)&gt;60; //select sname from student where sno in (select sno from sc groud by sno having avg(score)&gt;60); 查询语句作为另一条查询语句的一张表。一般解题步骤：先找到核心需求，确定最终要查的表，将每个条件用单独的一条select语句表示出来，将所写出的语句通过表之间的外键联系起来。 视图查询保存查询语句集的展示形式，保存结果集的表 create view view_student_sc as 链接查询结合多张表完成更复杂的查询需求分类： 内连接(INNER JOIN)select sno,sname from studentselect sno from sc groud by sno having avg(score) between 60 and 80select sno,sname from student where sno in (select sno from sc groud by sno having avg(score) between 60 and 80) select * from student inner join sc on sc.sno=student.sno groud by sno having avg(score) having between 60 and 80 外联接（左外，右外） 高级特效(包含了DCL) 变量 1.1 用户变量SET @变量名=变量值 // 定义变量select @变量名 //输出变量1.1.1 全局变量show global variable 查看所有的全局变量在 my-default.ini文件里面修改全局变量1.2 系统变量1.3 局部变量1234567891011121314create procedure pro_if()begindeclare a tinyint;select min(age) into a from student;if a&lt;18 thenselect &quot;小孩子&quot;;elseif a&gt;18 and a&lt;60 thenselect &quot;大孩子&quot;;elseselect &quot;老孩子&quot;;end if;endcall pro_if; 存储过程带参数的 输入的形参 和 输出的形参 输出的形参 触发器体现自定义完整性，构建更加合理、健壮的数据库，数据检查问题。 事务将多个操作视为一个整体的概念特性：原子性，一致性，隔离性，持久性。 游标]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB的使用]]></title>
    <url>%2F2018%2F10%2F25%2FmongoDB%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是MongoDB？ MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。 在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB的安装具体细节请参照该网站自行配置 MongoDB概念解析MongoDB的存储结构和以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件 基础Shell命令 show dbs :显示已有数据库，如果你刚安装好，会默认有local、admin(config)，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。 use admin： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。 show collections: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。 db:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。 数据操作基础命令 use db（建立数据库）：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。 db.集合.insert( ):新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。Demo：db.user.insert({“name”:”jspang”}) db.集合.find( ):查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。Demo：db.user.find() db.集合.findOne( ):查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。 db.集合.update({查询},{修改}):修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。 db.集合.remove(条件)：删除文件数据，注意的是要跟一个条件。Demo:db.user.remove({“name”:”jspang”}) db.集合.drop( ):删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。 db.dropDatabase( ):删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。 mongoose的使用Mongoose是一个开源的封装好的实现Node和MongoDB数据通讯的数据建模库。 mongoose的安装npm i mongoose -S 连接数据库在database目录下新建一个init.js文件。12345678910111213141516171819202122232425262728293031323334353637const mongoose = require(&apos;mongoose&apos;)const db = &quot;mongodb://localhost/smile-db&quot;exports.connect = ()=&gt;&#123; //连接数据库 mongoose.connect(db) let maxConnectTimes = 0 return new Promise((resolve,reject)=&gt;&#123; //把所有连接放到这里 //增加数据库监听事件 mongoose.connection.on(&apos;disconnected&apos;,()=&gt;&#123; console.log(&apos;***********数据库断开***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject() throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) mongoose.connection.on(&apos;error&apos;,err=&gt;&#123; console.log(&apos;***********数据库错误***********&apos;) if(maxConnectTimes&lt;3)&#123; maxConnectTimes++ mongoose.connect(db) &#125;else&#123; reject(err) throw new Error(&apos;数据库出现问题，程序无法搞定，请人为修理......&apos;) &#125; &#125;) //链接打开的时 mongoose.connection.once(&apos;open&apos;,()=&gt;&#123; console.log(&apos;MongoDB connected successfully&apos;) resolve() &#125;) &#125;)&#125; Mongoose的Schema建模Schema是以key-value形式Json格式的数据。 Schema中的数据类型 String ：字符串类型 Number ：数字类型 Date ： 日期类型 Boolean： 布尔类型 Buffer ： NodeJS buffer 类型 ObjectID ： 主键,一种特殊而且非常重要的类型 Mixed ：混合类型 Array ：集合类型 Mongoose中的三个概念 schema ：用来定义表的模版，实现和MongoDB数据库的映射。用来实现每个字段的类型，长度，映射的字段，不具备表的操作能力。 model ：具备某张表操作能力的一个集合，是mongoose的核心能力。我们说的模型就是这个Mondel。 entity ：类似记录，由Model创建的实体，也具有影响数据库的操作能力。 初学定义一个Schema我们在database文件夹下新建一个Schema文件下，然后创建一个use.js文件12345678910111213const mongoose = require(&apos;mongoose&apos;) //引入Mongooseconst Schema = mongoose.Schema //声明Schemalet ObjectId = Schema.Types.ObjectId //声明Object类型//创建我们的用户Schemaconst userSchema = new Schema(&#123; UserId:ObjectId, userName:&#123;unique:true,type:String&#125;, password:String, createAt:&#123;type:Date,default:Date.now()&#125;, lastLoginAt:&#123;type:Date,default:Date.now()&#125;&#125;)//发布模型mongoose.model(&apos;User&apos;,userSchema) 载入Schema和插入查出数据我们在init.js文件中处理Schema。首先我们载入所有的Schema，然后再处理。安装globnpm i glob -S12const glob = require(&apos;glob&apos;)const &#123;resolve&#125; = require(&apos;path&apos;) //将一系列相对路径替换成绝对路径 123exports.initSchemas = () =&gt;&#123; glob.sync(resolve(__dirname,&apos;./schema/&apos;,&apos;**/*.js&apos;)).forEach(require)&#125; 123456789101112131415161718192021222324const Koa = require(&apos;koa&apos;)const app = new Koa()const mongoose = require(&apos;mongoose&apos;)const &#123;connect , initSchemas&#125; = require(&apos;./database/init.js&apos;)//立即执行函数;(async () =&gt;&#123; await connect() initSchemas() const User = mongoose.model(&apos;User&apos;) let oneUser = new User(&#123;userName:&apos;jspang13&apos;,password:&apos;123456&apos;&#125;) oneUser.save().then(()=&gt;&#123; console.log(&apos;插入成功&apos;) &#125;)let users = await User.findOne(&#123;&#125;).exec()console.log(&apos;------------------&apos;)console.log(users)console.log(&apos;------------------&apos;) &#125;)()app.use(async(ctx)=&gt;&#123; ctx.body = &apos;&lt;h1&gt;hello Koa2&lt;/h1&gt;&apos;&#125;)app.listen(3000,()=&gt;&#123; console.log(&apos;[Server] starting at port 3000&apos;)&#125;)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node学习]]></title>
    <url>%2F2018%2F10%2F24%2Fnode%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Node.js是什么？ Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js的安装和配置这个在这里不过多阐述，更多内容请自行百度。 第一个Node.js文件在一个目录下创建一个nodejs的文件夹,同时在该文件夹下创建一个HelloWorld.js文件，其内容为1console.log(&apos;Hello,World!&apos;); 然后打开终端，进入该文件目录下，使用node HelloWorld.js就可以在终端看到 Hello,World!的字了，并且第一个nodejs文件就完成了。 node核心模块node具有众多的核心模块，比较常用的有 fs,http,path等 fs模块fs是node中用于 读取文件的，它常用的有 readFile()和writeFile()这两个方法，第一个参数都是文件地址，readFile()第二个参数就是一个回调函数，而writeFile()由于是写文件，故应当有写入内容，所以其第二个参数是data(string)，然后跟一个回调函数。 readFile()方法12345678910var fs = require(&apos;fs&apos;);fs.readFile(&apos;1.txt&apos;, (error, data) =&gt; &#123; if(error) &#123; console.log(&apos;读取文件失败，请稍后再试&apos;) &#125; else &#123; console.log(data.toString()) //读取的数据大多是二进制数据，所以需要将其转换为字符类型 &#125;&#125;) 同理，writeFile()方法12345678910var fs = require(&apos;fs&apos;);fs.writeFile(&apos;2.txt&apos;, &apos;我是写入的内容&apos;, (error) =&gt; &#123; if(error) &#123; console.log(&apos;写入文件失败，请稍后再试&apos;) &#125; else &#123; console.log(&apos;写入文件成功&apos;) &#125;&#125;) 比较上面两段代码，可以清楚的知道，readFile()方法有两个参数，而回调函数中有两个参数（error和data）；而writeFile()方法有三个参数，而回调函数就只有一个参数（error）了。 http模块http模块主要用于搭建http服务器，我们可以利用其构建后端服务，使我们的应用在web服务器上使用。1234567891011121314151617181920var http = require(&apos;http)var server = http.createServer()server.on(&apos;request&apos;, (req, res) =&gt; &#123; var url = res.url; if(url === &apos;/&apos;) &#123; fs.readFile(&apos;./index.html&apos;, (error, data) =&gt; &#123; if(error) &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain;charset=utf-8&apos;) res.end(&apos;读取文件失败，请稍后再试！&apos;) &#125; else &#123; res.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;) res.end(data) &#125; &#125;) &#125;&#125;)server.listen(3000, () =&gt; &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 常用查询Content-Type的网站 node实现Apache1234567891011121314151617181920212223var http = require(&apos;http&apos;)var fs = require(&apos;fs&apos;)var server = http.createServer()server.on(&apos;request&apos;, function(req, res) &#123; var url = req.url var pathFile = &apos;index.html&apos; if(pathFile !== &apos;/&apos;) &#123; pathFile = url &#125; fs.readFile(pathFile, function(err, data) &#123; if(err) &#123; console.log(&apos;读取文件失败&apos;) &#125; else &#123; res.end(data) &#125; &#125;) &#125;)server.listen(3000, function() &#123; console.log(&apos;the server is starting at port 3000!&apos;)&#125;) expressexpress作为一个被node封装好的http框架，使用十分频繁和场景。12345678910var express = require(&apos;express&apos;)var app = new express()app.get(&apos;/&apos;, function(req, res) &#123; res.end(&apos;这是主页面&apos;)&#125;)app.listen(3000, function() &#123; console.log(&apos;The server is starting at port 3000!&apos;)&#125;) 使用express完成一个crud 模版引擎的安装npm i art-template express-art-template -S在文件中使用 123456配置art-template模版引擎app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))渲染模版引擎res.render(&apos;index.html&apos;, &#123; // 传入的对象通常是字符串需要通过JSON.parse()转移&#125;) 完整代码 123456789101112131415161718192021222324252627// 引包var express = require(&apos;express&apos;)var fs = require(&apos;fs&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求app.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;)// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;) router路由模块通常情况下，我们将需要请求的路径封装成一个router.js文件，里面封装好我们需要的路径和相应的请求回调函数和逻辑，使我们的文件逻辑清晰。1234567891011121314151617181920212223242526272829303132var express = require(&apos;express&apos;)var router = express.Router()var fs = require(&apos;fs&apos;)router.get(&apos;/&apos;, function(req, res) &#123; fs.readFile(&apos;./db.json&apos;, &apos;utf8&apos;, function(err, data) &#123; if(err) &#123; return res.status(500).send(&apos;error!&apos;) &#125; res.render(&apos;index.html&apos;, &#123; user: JSON.parse(data).user &#125;) &#125;)&#125;) router.get(&apos;/students&apos;, function(req, res) &#123;&#125;) router.post(&apos;/students&apos;, function(req, res) &#123;&#125;) router.get(&apos;/students/new&apos;, function(req, res) &#123;&#125;)router.post(&apos;/students/new&apos;, function(req, res) &#123;&#125;)module.exports = router 而在我们的app.js文件中就可以写成这样了1234567891011121314151617181920212223// 引包var express = require(&apos;express&apos;)var router = require(&apos;./router.js&apos;)// 创建服务器var app = new express()// 配置公共资源app.use(&apos;/public/&apos;, express.static(&apos;./public&apos;))// 使用路由app.use(router)app.engine(&apos;html&apos;, require(&apos;express-art-template&apos;))// 配置请求// 监听请求app.listen(3000,function() &#123; console.log(&apos;running 3000&apos;)&#125;)module.exports = app 最后完整版app.js123456789101112131415161718192021222324252627//引包const express=require(&apos;express&apos;);const fs=require(&apos;fs&apos;);const bodyParser=require(&apos;body-parser&apos;);//用户路由routerconst user=require(&apos;./router/user&apos;);//创建服务器const app=express();//配置公共资源app.use(express.static(&apos;./public&apos;));//配置使用art-template 模版引擎app.engine(&apos;html&apos;,require(&apos;express-art-template&apos;));//配置body-parserapp.use(bodyParser.urlencoded(&#123;extended:false&#125;));app.use(bodyParser.json());//分发路由app.use(user);//监听端口app.listen(3000,function()&#123; console.log(&apos;Server is Start&apos;);&#125;); userModel.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/**数据操作模块只负责处理数据*/const fs=require(&apos;fs&apos;);const DB=&apos;./db.json&apos;/*获得所有用户return []*/exports.findAllUser=function(callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; callback(null,JSON.parse(data).users); &#125; &#125;);&#125;/*根据id查找user*/exports.findUserById=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error,null); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===id; &#125;); callback(null,findUser); &#125; &#125;);&#125;/*添加用户*/exports.addUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //设置id user.id =+users[users.length-1].id+1; user.id=user.id.toString(); //添加 users.push(user); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*修改用户*/exports.updateUser=function(user,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; var users=JSON.parse(data).users; //查找指定id的user var users=JSON.parse(data).users; var findUser=users.find(function(item)&#123; return item.id===user.id; &#125;); //修改 for(var key in findUser)&#123; findUser[key]=user[key]; &#125; var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125;/*删除用户*/exports.DeleteUser=function(id,callback)&#123; fs.readFile(DB,&apos;utf-8&apos;,function(error,data)&#123; if (error) &#123; callback(error); &#125;else &#123; //查找指定id的user var users=JSON.parse(data).users; var deleteUserID=users.findIndex(function(item)&#123; return item.id===id; &#125;); //删除数据 users.splice(deleteUserID,1); var saveString=JSON.stringify(&#123; users:users &#125;); //写入数据 fs.writeFile(DB,saveString,function(error)&#123; if(error)&#123; callback(error); &#125;else &#123; callback(null); &#125; &#125;); &#125; &#125;);&#125; router.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//路由模块 根据请求路径配置请求方法//引包const express=require(&apos;express&apos;);//挂载Express的路由routerconst router=express.Router();//加载模型const userModel=require(&apos;../model/userModel&apos;);//设置文件数据库路径const dbPath=&apos;./db.json&apos;;//配置请求//查看用户列表router.get(&apos;/user&apos;,function(req,res)&#123; userModel.findAllUser(function(error,data)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;index.html&apos;,&#123; user:data &#125;); &#125; &#125;);&#125;);//添加用户页面router.get(&apos;/user/add&apos;,function(req,res)&#123;res.render(&apos;useradd.html&apos;);&#125;);//添加用户操作router.post(&apos;/user/add&apos;,function(req,res)&#123;var user=req.body;userModel.addUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//更新修改页面router.get(&apos;/user/update&apos;,function(req,res)&#123;var id=req.query.id;userModel.findUserById(id,function(error,data)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.render(&apos;userUpdate.html&apos;,&#123;user:data&#125;); &#125;&#125;);&#125;);//更新数据router.post(&apos;/user/update&apos;,function(req,res)&#123; var user=req.body; userModel.updateUser(user,function(error)&#123; if(error)&#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125; &#125;);&#125;);//删除数据router.get(&apos;/user/Delete&apos;,function(req,res)&#123;var id=req.query.id;userModel.DeleteUser(id,function(error)&#123; if (error) &#123; return res.status(500).send(&apos;Server Error!!&apos;); &#125;else &#123; res.redirect(&apos;/user&apos;); &#125;&#125;);&#125;);//导出routermodule.exports=router;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
</search>
